package org.example.collections.practice.exercises;

import java.util.*;

/**
 * Problem Statement:
 * Given a stream (array) of characters, return the first non-repeating character seen so far after
 * each new character is processed.
 * If there's no non-repeating character, return null.
 */
public class P002 implements Exercise {
    char[] streamArr = {'A', 'B', 'C', 'A', 'C', 'D', 'B', 'E'};

    @Override
    public void resolveExercise() {
        // Solution here:
        var linkedList = new LinkedList<AbstractMap.SimpleEntry<Character, LinkedHashMap<Character, Integer>>>();
        var i = 1;
        for(char item : streamArr) {
            if (i == streamArr.length) {
                linkedList.add(new AbstractMap.SimpleEntry<>(item, new LinkedHashMap<>())); // TODO changin from TreeMap toLinkedHashMap since it is faster for get, put, remove operations
                break;
            }

            var arr = Arrays.copyOfRange(streamArr, i, streamArr.length);
            var arrList = new ArrayList<Character>();
            for (char c : arr) {
                arrList.add(c);
            }
            var sortedMap = new LinkedHashMap<Character, Integer>();
            arrList.forEach(c -> sortedMap.merge(c, 1, Integer::sum));

            linkedList.add(new AbstractMap.SimpleEntry<>(item, sortedMap));
            i++;
        }

        linkedList.forEach(item -> {

            var res = item.getValue().entrySet().stream().filter(xx -> xx.getValue().equals(1)).findFirst();
            var result = res.orElse(null);
            var resultx = result == null ? null : result.getKey();
            System.out.println(item.getKey() + " → " + resultx);
        });
    }

//    static class Pair {  // todo I created this because Pair is in the javafx.util package but I did not want to add the dependencies..
//        public char k;   // todo   then I replaced it for SimpleEntry map
//        public TreeMap<Character, Integer> v;
//
//        public Pair(char key, TreeMap<Character, Integer> val) {
//            this.k = key;
//            this.v = val;
//        }
//    }

    /**
     * Explanation:
     * This exercise was generated by AI, what it wanted was to get the existing frequency of at the moment of each
     * element... that was clearly not well explained.. what I did was evaluate items ahead of each element
     * but here is the solution for what the AI wanted..
     */
    @Deprecated
    private void aiSolution() {
        char[] streamArr = {'A', 'B', 'C', 'A', 'C', 'D', 'B', 'E'};


        Map<Character, Integer> countMap = new LinkedHashMap<>(); // Maintains insertion order

        for (char ch : streamArr) {
            countMap.put(ch, countMap.getOrDefault(ch, 0) + 1);

            Character firstNonRepeating = null;
            for (Map.Entry<Character, Integer> entry : countMap.entrySet()) {
                if (entry.getValue() == 1) {
                    firstNonRepeating = entry.getKey();
                    break;
                }
            }

            System.out.println(ch + " → " + firstNonRepeating);
        }
    }
}
